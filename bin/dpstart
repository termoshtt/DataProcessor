#!/usr/bin/env python
# coding=utf-8

import os.path
import sys
import traceback
import tempfile
import subprocess
import shutil
from datetime import datetime

sys.path = ([sys.path[0]]
            + [os.path.join(os.path.dirname(__file__), "../lib")]
            + sys.path[1:])
import dataprocessor as dp
sys.path = [sys.path[0]] + sys.path[2:]


run_template = """#!/bin/sh
# created by DataProcessor dpstart
cd {path}
{args}
"""


def main(cfg):
    start_str = datetime.now().strftime("%FT%T")
    run_root = dp.rc.get_run_dir(cfg.root)
    path = dp.utility.get_directory(os.path.join(run_root, start_str))
    parents = projects(cfg)
    name = cfg.name if cfg.name else start_str
    git_hash = check_git_status(cfg)
    make(cfg)
    copy_requires(cfg, path)

    tmp = tempfile.NamedTemporaryFile()
    tmp.write(run_template.format(path=path, args=" ".join(cfg.args)))
    tmp.flush()
    subprocess.check_call(['at', 'now', '-f', tmp.name])

    node = {
        "path": path,
        "name": name,
        "type": "run",
        "parents": parents,
        "children": [],
        "start": start_str,
        "args": cfg.args,
        "hash": git_hash,
    }
    with dp.io.SyncDataHandler(cfg.json, silent=True) as dh:
        node_list = dh.get()
        dp.nodes.add(node_list, node)


def check_git_status(cfg):
    if cfg.nocheck:
        return
    if not cfg.nocheck_modified and not dp.git.no_modified():
        raise dp.exception.DataProcessorError("There is modified file")
    if not cfg.nocheck_untracked and not dp.git.no_untracked():
        raise dp.exception.DataProcessorError("There is untracked file")
    return dp.git.get_hash()


def copy_requires(cfg, path):
    for a in cfg.args:
        here = dp.utility.path_expand(".")
        item = dp.utility.path_expand(a)
        if item[:len(here)] == here and os.path.exists(item):
            cfg.require.append(item)
    for fn in cfg.require:
        from_path = dp.utility.check_file(fn)
        to_path = os.path.join(path, os.path.basename(fn))
        shutil.copy2(from_path, to_path)


def projects(cfg):
    exe = os.path.basename(cfg.args[0])
    exe_path = os.path.join(dp.rc.get_project_dir(cfg.root), exe)
    exe_path = dp.utility.get_directory(exe_path)
    cfg.project.append(exe_path)

    projects = []
    with dp.io.SyncDataHandler(cfg.json, silent=True) as dh:
        node_list = dh.get()
        for p in cfg.project:
            path = dp.utility.check_directory(p)
            node = dp.nodes.get(node_list, path)
            if not node:
                dp.nodes.add(node_list, {
                    "path": path,
                    "name": os.path.basename(path),
                    "type": "project",
                    "parents": [],
                    "children": [],
                })
            projects.append(path)
    return projects


def make(cfg):
    if not cfg.make:
        return
    if isinstance(cfg.make, str):
        subprocess.check_call(["make", cfg.make])
    else:
        subprocess.check_call(["make"])


def parse():
    parser = dp.rc.ArgumentParser()
    parser.add_argument("args", nargs='+', help="exec")
    parser.add_argument("-r", "--require", nargs='+', default=[],
                        help="required files")
    parser.add_argument("-n", "--name",  help="run name")
    parser.add_argument("-p", "--project", nargs='+', default=[],
                        help="project name")
    parser.add_argument("-m", "--make", nargs="?", default=False, const=True,
                        help="make before run")
    parser.add_argument("--nocheck", action="store_true",
                        help="Do not check git status")
    parser.add_argument("--nocheck_untracked", action="store_true",
                        help="Do not check untracked files")
    parser.add_argument("--nocheck_modified", action="store_true",
                        help="Do not check modified files")
    return parser.parse_args()

if __name__ == '__main__':
    args = parse()
    try:
        main(args)
    except dp.exception.DataProcessorError as e:
        if args.debug:
            print(traceback.format_exc())
        print("=*= ERROR =*=")
        print("Message: %s" % e.msg)
        sys.exit(1)
